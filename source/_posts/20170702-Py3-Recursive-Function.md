---
title: Python 3 中对递归函数及其经典示例的思考
date: 2017-07-02 13:03:58
tags:
  - Python
---

# 感谢廖雪峰大神的教程！

# 递归 与 尾递归

  递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
  
  如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。
  
## 递归算法的应用

  递归算法，在很大程度上减少了代码量，尽可能减少了使用循环时重复判定带来的逻辑不清与出现错误的可能性，可以帮助程序员更专注于思维和程序功能的实验，而并非冗杂的语法逻辑转换。尾递归则在递归算法的基础上进一步优化，在返回时不再涉及运算式，尽可能能地调用原函数代码，利用这个特性，可以提高堆栈利用率，减少出现堆栈溢出的可能。
  
  以Python3为例，下同，我们定义一个阶乘函数。
  
```
  def fact1(n):  # equals to n * n-1 * n-2 * .....* 3 * 2 * 1
    if n == 1:
        return 1
    return n * fact1(n - 1)
```

  当你输入fact1(100)可能不会有差别，然而当你输入fact1(998)的时候，你就会得到下面的提示（Python本身的限制是1000，这个溢出的界限取决于机器，我的服务器就可以执行fact1(999)，我的笔记本就不行）：
  
> RecursionError: maximum recursion depth exceeded in comparison
> Process finished with exit code 1

  实际上，我们可以通过写成尾递归的形式对其进行优化：
  
```
def fact2(n):
    return  fact2_iter(n,1)

def fact2_iter(num,product):
    if num == 1 :
        return product
    return fact2_iter(num - 1 , num * product)
```

解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中。

> **然而，不幸的是，仅有少部分高级语言的解释器对尾递归进行了优化，对于Python3和绝大多数语言解释器而言，尾递归是没有任何优化的。** 尽管如此，为了使你的代码具有更高的资源利用率，我还是建议你写成尾递归的形式。

# 经典示例

## 示例一 ： 汉诺塔的递归实验

### 老样子，先上算法：

```
def move(CircleatA, LocA='A Pipe', LocB='B Pipe', LocC='C Pipe'):
    if CircleatA == 1:
        print('move', LocA, '-->', LocC)
    else:
        move(CircleatA - 1, LocA, LocC, LocB)
        move(1, LocA, LocB, LocC)
        move(CircleatA - 1, LocB, LocA, LocC)
```

### 算法与数学分析

> 参考资料： https://www.zhihu.com/question/24385418

#### 问题背景

有A,B,C三根针，将A针上N个从小到大叠放的盘子移动到C针，一次只能移动一个，不重复移动，小盘子必须在大盘子上面。

### 0x01 思路

> 1. 只有经历“移动最大盘子”这个步骤，余下的事情才有可能实现。而在此之前，我们所要做的事情，就是让“移动最大盘子”这个步骤得以实现。现在，游戏整个过程以“移动最大盘子”为中央，被分为了两部分。即（前）“将那坨N-1个盘子从A针移动到B针”，(中)“移动最大盘子”，(后)“将坨N-1个盘子从B针移动到C针”。这是我们意识到，（前）与（后）操作道理是相似的。不去管那个最大盘子，（前）是以C针为中转站，（后）是以A针为中转站。因此两者所需的移动次数应当是相等的。这意味着我们只要计算出其中一者的移动次数，然而乘以2，在加上“移动最大盘子”的那1次，就是这场游戏的总移动次数了。用数学语言表达，假设（前）“将N-1个盘子从A针移动到B针”所需次数为H(n-1)，总移动次数为H(n)，那么可以得出的关系就是：H(n)= H(n-1) x 2 + 1.

### 0x02 证明最优解

> 最基本的情况，即n为1，就不用说了。现在F(n-1)确实是把n-1个盘子集体挪动的最小步数，我们要证明F(n)是把n个盘子集体挪动的最小步数。

> 1）在把n个盘子从A移动到C的过程中，必然存在一步，是把最大的盘子从A拿出来。要想把最大的盘子从A移动到别的某个柱子上（B或C），就必须保证剩下的n-1个盘子不能碍事，得好好堆在剩下那个柱子（C或B）上。要保证n-1个盘子都在剩下那个柱子上，至少得付出F(n-1)次移动。

> 2）在把n个盘子从A移动到C的过程中，必然存在一步，是最大的盘子被放到了C上，而且此后再也没动过。在这步实行之前，最大的盘子要么在A要么在B上，而相应地别的n-1个盘子要么在B要么在A上。在这步实施之后，我们只要花至少F(n-1)的步数把n-1个盘子从要么B要么A挪动到C上就行了。这些步数必然和1）中的步数不重叠，因为这时候最大盘子在C上，而1）中最大盘子在A上。

> 3）最大的盘子至少被挪动了一次。而且这一次肯定没被算在1）或2）的“至少F(n-1)步”中，因为后者只挪动较小的那n-1个盘子。把1），2），3）加起来，就是至少F(n-1) + F(n-1) + 1步。不能再少了。

### 0x03 程序运行简析

> 首先，你需要先理解n=2的情况，非常简单：
> n=2时：执行move(1,a,c,b)，打印出A-->B；
> 执行A-->C；
> 执行move(1,b,a,c)，打印出B-->C；
> 因此n=2时，相当于是将A中的两个盘子按照规则搬到了C中。

> n=3时：执行move(2,a,c,b)，带入我们之前所理解的结果，即将A中的上面2个盘子按照规则搬到了B中，并且打印出过程；
将A中最下面的盘子搬到c中，打印A-->C； 执行move(2,b,a,c)，即将B中的2个盘子按规则搬到C中，并且打印出过程。

> *n=4时程序基于n=3上运行，一层套一层，这就是递归。*

### 0x04 汉诺塔问题的通解

> 最关键的一个步骤在于最大的盘子是否挪到目标柱子，在最大的盘子挪到目标柱子以后，它将不应在参与移动。
>　因为剩下的任何盘子都可以移动到最大的盘子上面，于是我们就可以无视掉它。
> 在汉诺塔中，有这样三个步骤简单的说，就是这3步：1. 最大号盘子没有挪动到目标柱子，我们创造机会让它过去（把冰箱门打开）2. 把最大号挪动到目标柱子（把大象装进去）3. 把剩下的盘子挪到最大号盘子上（把冰箱门关上）设起始柱子为A，中介柱子为B，目标柱子为C

> *注意，不要落入ABC三个柱子的局限之中，ABC在不同的循环步骤之中，不一定代表起始柱子，中介柱子和目标柱子。最小的盘子为编号1，最大的盘子为编号n*

### 0x05 终极之战，函数问题的抽象化

![9e868e86b16f18d153bff7811e94367a_b.png](https://ooo.0o0.ooo/2017/07/02/595907560f6f3.png)

(a)是初始状态，也就是递归的起点，我们假设n=4， move(4,A,B,C)还是请参考现在最高的分的代码哈~
写这个是帮助大家更清楚那个让人压力大的（“抽象”）两个字，哈哈     <这个函数要实现的功能是把n个环从A按照一定的规则，借助B，移动到C>

(b)是step1完成的时候的状态，已经将所有的n-1,这里也就是3个环从A挪到了B     <第一处递归，move(n-1,A,C,B) 这个函数要实现将n-1个环从A，借助C，移动到B>

(c)是step2，此时需要将第n个，也就是第四个最大的环从A挪到C      <move(1,A,B,C)，或者干脆直接print("A -> C")>

(d)是step3，此时需要将B上面的n-1个环从B挪到C<第二处递归>     <第二处递归，move(n-1,B,A,C) 这个函数要实现将n-1个环从B，借助A，移动到C>

代码参见： https://github.com/kmahyyg/learn_py3

## 示例2 ： 斐波那契数列


请直接参考C语言实现。